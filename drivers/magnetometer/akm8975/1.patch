--- akm8975.c	2013-01-03 12:38:39.000000000 +0200
+++ akm8975c.c	2013-01-13 19:19:19.000000000 +0200
@@ -1,40 +1,7 @@
-/* Copyright Statement:
+/* drivers/i2c/chips/akm8975.c - akm8975 compass driver
  *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- */
-/* MediaTek Inc. (C) 2010. All rights reserved.
- *
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
-
-/* akm8975.c - akm8975 compass driver
- * 
+ * Copyright (C) 2007-2008 HTC Corporation.
+ * Author: Hou-Kun Chen <houkun.chen@gmail.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -47,76 +14,33 @@
  *
  */
 
+/*
+ * Revised by AKM 2009/04/02
+ * 
+ */
+
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/slab.h>
 #include <linux/irq.h>
 #include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-#include <asm/atomic.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
 #include <linux/delay.h>
 #include <linux/input.h>
 #include <linux/workqueue.h>
-#include <linux/kobject.h>
-#include <linux/platform_device.h>
+#include <linux/freezer.h>
+#include <linux/i2c/akm8975c.h>
 #include <linux/earlysuspend.h>
 
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-
-
-#ifdef MT6516
-#include <mach/mt6516_devs.h>
-#include <mach/mt6516_typedefs.h>
-#include <mach/mt6516_gpio.h>
-#include <mach/mt6516_pll.h>
-#endif
-
-#ifdef MT6573
-#include <mach/mt6573_devs.h>
-#include <mach/mt6573_typedefs.h>
-#include <mach/mt6573_gpio.h>
-#include <mach/mt6573_pll.h>
-#endif
-
-#ifdef MT6575
-
-#include <mach/mt6575_devs.h>
-#include <mach/mt6575_typedefs.h>
-#include <mach/mt6575_gpio.h>
-#include <mach/mt6575_pm_ldo.h>
-#endif
-
-/*-------------------------MT6516&MT6573 define-------------------------------*/
-#ifdef MT6516
-#define POWER_NONE_MACRO MT6516_POWER_NONE
-#endif
-
-#ifdef MT6573
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-#endif
-
-#ifdef MT6575
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-#endif
-
-
-#include <cust_mag.h>
-#include "akm8975.h"
-#include <linux/hwmsen_helper.h>
-/*----------------------------------------------------------------------------*/
-#define DEBUG 1
-#define AKM8975_DEV_NAME         "akm8975"
-#define DRIVER_VERSION          "1.0.1"
-/*----------------------------------------------------------------------------*/
-#define AKM8975_DEBUG		1
-#define AKM8975_DEBUG_MSG	1
-#define AKM8975_DEBUG_FUNC	1
-#define AKM8975_DEBUG_DATA	1
-#define MAX_FAILURE_COUNT	3
-#define AKM8975_RETRY_COUNT	10
+#define AKM8975_DEBUG			1
+#define AKM8975_DEBUG_MSG		1
+#define AKM8975_DEBUG_FUNC		0
+#define AKM8975_DEBUG_DATA		0
+#define MAX_FAILURE_COUNT		3
+#define AKM8975_RETRY_COUNT		10
 #define AKM8975_DEFAULT_DELAY	100
+//#define AKM8975_USING_IRQ
 
 #if AKM8975_DEBUG_MSG
 #define AKMDBG(format, ...)	printk(KERN_INFO "AKM8975 " format "\n", ## __VA_ARGS__)
@@ -130,170 +54,87 @@
 #define AKMFUNC(func)
 #endif
 
-static struct i2c_client *this_client = NULL;
+static struct i2c_client *this_client;
+
+struct akm8975_data {
+	struct input_dev *input_dev;
+	struct work_struct work;
+	struct early_suspend akm_early_suspend;
+};
 
 /* Addresses to scan -- protected by sense_data_mutex */
+#ifdef AKM8975_USING_IRQ
 static char sense_data[SENSOR_DATA_SIZE];
 static struct mutex sense_data_mutex;
-// calibration msensor and orientation data
-static short sensor_data[CALIBRATION_DATA_SIZE];
-static struct mutex sensor_data_mutex;
+#endif
 static DECLARE_WAIT_QUEUE_HEAD(data_ready_wq);
 static DECLARE_WAIT_QUEUE_HEAD(open_wq);
 
-static short akmd_delay = AKM8975_DEFAULT_DELAY;
-
-static atomic_t open_flag = ATOMIC_INIT(0);
-static atomic_t m_flag = ATOMIC_INIT(0);
-static atomic_t o_flag = ATOMIC_INIT(0);
-
-static int factory_mode=0;
-
-/*----------------------------------------------------------------------------*/
-/*----------------------------------------------------------------------------*/
-static const struct i2c_device_id akm8975_i2c_id[] = {{AKM8975_DEV_NAME,0},{}};
-#if defined(ACER_C8)
-static struct i2c_board_info __initdata i2c_akm8975={ I2C_BOARD_INFO("akm8975", (0x1e>>1))};
-#else
+static atomic_t data_ready;
+static atomic_t open_count;
+static atomic_t open_flag;
+static atomic_t reserve_open_flag;
+
+static atomic_t m_flag;
+static atomic_t a_flag;
+static atomic_t mv_flag;
+static atomic_t p_flag;
 
-static struct i2c_board_info __initdata i2c_akm8975={ I2C_BOARD_INFO("akm8975", (0x18>>1))};
+#ifdef AKM8975_USING_IRQ
+static int failure_count = 0;
 #endif
 
-/*the adapter id will be available in customization*/
-//static unsigned short akm8975_force[] = {0x00, AKM8975_I2C_ADDRESS, I2C_CLIENT_END, I2C_CLIENT_END};
-//static const unsigned short *const akm8975_forces[] = { akm8975_force, NULL };
-//static struct i2c_client_address_data akm8975_addr_data = { .forces = akm8975_forces,};
-/*----------------------------------------------------------------------------*/
-static int akm8975_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id); 
-static int akm8975_i2c_remove(struct i2c_client *client);
-static int akm8975_i2c_detect(struct i2c_client *client, int kind, struct i2c_board_info *info);
-static int akm_probe(struct platform_device *pdev);
-static int akm_remove(struct platform_device *pdev);
-
-
-/*----------------------------------------------------------------------------*/
-typedef enum {
-    AMK_FUN_DEBUG  = 0x01,
-	AMK_DATA_DEBUG = 0X02,
-	AMK_HWM_DEBUG  = 0X04,
-	AMK_CTR_DEBUG  = 0X08,
-	AMK_I2C_DEBUG  = 0x10,
-} AMK_TRC;
-
-
-/*----------------------------------------------------------------------------*/
-struct akm8975_i2c_data {
-    struct i2c_client *client;
-    struct mag_hw *hw; 
-    atomic_t layout;   
-    atomic_t trace;
-	struct hwmsen_convert   cvt;
-#if defined(CONFIG_HAS_EARLYSUSPEND)    
-    struct early_suspend    early_drv;
-#endif 
-};
-/*----------------------------------------------------------------------------*/
-static struct i2c_driver akm8975_i2c_driver = {
-    .driver = {
-//        .owner = THIS_MODULE, 
-        .name  = AKM8975_DEV_NAME,
-    },
-	.probe      = akm8975_i2c_probe,
-	.remove     = akm8975_i2c_remove,
-	.detect     = akm8975_i2c_detect,
-#if !defined(CONFIG_HAS_EARLYSUSPEND)
-	.suspend    = akm8975_suspend,
-	.resume     = akm8975_resume,
-#endif 
-	.id_table = akm8975_i2c_id,
-//	.address_data = &akm8975_addr_data,
-};
-
-/*----------------------------------------------------------------------------*/
-static struct platform_driver akm_sensor_driver = {
-	.probe      = akm_probe,
-	.remove     = akm_remove,    
-	.driver     = {
-		.name  = "msensor",
-//		.owner = THIS_MODULE,
-	}
-};
+static short akmd_delay = AKM8975_DEFAULT_DELAY;
 
+static atomic_t suspend_flag = ATOMIC_INIT(0);
+#ifdef AKM8975_USING_IRQ
 
-/*----------------------------------------------------------------------------*/
-static atomic_t dev_open_count;
-/*----------------------------------------------------------------------------*/
-static void akm8975_power(struct mag_hw *hw, unsigned int on) 
-{
-	static unsigned int power_on = 0;
-
-	if(hw->power_id != POWER_NONE_MACRO)
-	{        
-		AKMDBG("power %s\n", on ? "on" : "off");
-		if(power_on == on)
-		{
-			AKMDBG("ignore power control: %d\n", on);
-		}
-		else if(on)
-		{
-			if(!hwPowerOn(hw->power_id, hw->power_vol, "akm8975")) 
-			{
-				printk(KERN_ERR "power on fails!!\n");
-			}
-		}
-		else
-		{
-			if(!hwPowerDown(hw->power_id, "akm8975")) 
-			{
-				printk(KERN_ERR "power off fail!!\n");
-			}
-		}
-	}
-	power_on = on;
-}
+static struct akm8975_platform_data *pdata;
+#endif
 static int AKI2C_RxData(char *rxData, int length)
 {
 	uint8_t loop_i;
-
-#if DEBUG
+	struct i2c_msg msgs[] = {
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = rxData,
+		},
+		{
+			.addr = this_client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = rxData,
+		},
+	};
+#if AKM8975_DEBUG_DATA
 	int i;
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
 	char addr = rxData[0];
 #endif
-
-
+#ifdef AKM8975_DEBUG
 	/* Caller should check parameter validity.*/
-	if((rxData == NULL) || (length < 1))
-	{
+	if ((rxData == NULL) || (length < 1)) {
 		return -EINVAL;
 	}
-
-	for(loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++)
-	{
-		this_client->addr = this_client->addr & I2C_MASK_FLAG | I2C_WR_FLAG;
-		if(i2c_master_send(this_client, (const char*)rxData, ((length<<0X08) | 0X01)))
-		{
+#endif
+	for (loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++) {
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0) {
 			break;
 		}
 		mdelay(10);
 	}
 	
-	if(loop_i >= AKM8975_RETRY_COUNT)
-	{
+	if (loop_i >= AKM8975_RETRY_COUNT) {
 		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8975_RETRY_COUNT);
 		return -EIO;
 	}
-#if DEBUG
-	if(atomic_read(&data->trace) & AMK_I2C_DEBUG)
-	{
-		printk(KERN_INFO "RxData: len=%02x, addr=%02x\n  data=", length, addr);
-		for(i = 0; i < length; i++)
-		{
-			printk(KERN_INFO " %02x", rxData[i]);
-		}
-	    printk(KERN_INFO "\n");
+#if AKM8975_DEBUG_DATA
+	printk(KERN_INFO "RxData: len=%02x, addr=%02x\n  data=", length, addr);
+	for (i = 0; i < length; i++) {
+		printk(KERN_INFO " %02x", rxData[i]);
 	}
+    printk(KERN_INFO "\n");
 #endif
 	return 0;
 }
@@ -301,44 +142,40 @@
 static int AKI2C_TxData(char *txData, int length)
 {
 	uint8_t loop_i;
-	
-#if DEBUG
+	struct i2c_msg msg[] = {
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = length,
+			.buf = txData,
+		},
+	};
+#if AKM8975_DEBUG_DATA
 	int i;
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
 #endif
-
+#ifdef AKM8975_DEBUG
 	/* Caller should check parameter validity.*/
-	if ((txData == NULL) || (length < 2))
-	{
+	if ((txData == NULL) || (length < 2)) {
 		return -EINVAL;
 	}
-
-	this_client->addr = this_client->addr & I2C_MASK_FLAG;
-	for(loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++)
-	{
-		if(i2c_master_send(this_client, (const char*)txData, length) > 0)
-		{
+#endif	
+	for (loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++) {
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0) {
 			break;
 		}
 		mdelay(10);
 	}
 	
-	if(loop_i >= AKM8975_RETRY_COUNT)
-	{
+	if (loop_i >= AKM8975_RETRY_COUNT) {
 		printk(KERN_ERR "%s retry over %d\n", __func__, AKM8975_RETRY_COUNT);
 		return -EIO;
 	}
-#if DEBUG
-	if(atomic_read(&data->trace) & AMK_I2C_DEBUG)
-	{
-		printk(KERN_INFO "TxData: len=%02x, addr=%02x\n  data=", length, txData[0]);
-		for(i = 0; i < (length-1); i++)
-		{
-			printk(KERN_INFO " %02x", txData[i + 1]);
-		}
-		printk(KERN_INFO "\n");
+#if AKM8975_DEBUG_DATA
+	printk(KERN_INFO "TxData: len=%02x, addr=%02x\n  data=", length, txData[0]);
+	for (i = 0; i < (length-1); i++) {
+		printk(KERN_INFO " %02x", txData[i + 1]);
 	}
+	printk(KERN_INFO "\n");
 #endif
 	return 0;
 }
@@ -346,7 +183,8 @@
 static int AKECS_SetMode_SngMeasure(void)
 {
 	char buffer[2];
-		
+	
+	atomic_set(&data_ready, 0);
 	
 	/* Set measure mode */
 	buffer[0] = AK8975_REG_CNTL;
@@ -420,144 +258,135 @@
 {
 	char buffer[2];
 	int ret;
-	AKMDBG(" AKM check device id");
+	
 	/* Set measure mode */
 	buffer[0] = AK8975_REG_WIA;
-
+	
 	/* Read data */
 	ret = AKI2C_RxData(buffer, 1);
-	AKMDBG(" AKM check device id = %x",buffer[0]);
-	AKMDBG("ret = %d",ret);
-	if(ret < 0)
-	{
+	if (ret < 0) {
 		return ret;
 	}
 	/* Check read data */
-	if(buffer[0] != 0x48)
-	{
+	if (buffer[0] != 0x48) {
 		return -ENXIO;
 	}
 	
 	return 0;
 }
 
-// Daemon application save the data
-static int AKECS_SaveData(short *buf)
-{
-#if DEBUG	
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-#endif
-
-	mutex_lock(&sensor_data_mutex);
-	memcpy(sensor_data, buf, sizeof(sensor_data));	
-	mutex_unlock(&sensor_data_mutex);
-	
-#if DEBUG
-	if(atomic_read(&data->trace) & AMK_HWM_DEBUG)
-	{
-		AKMDBG("Get daemon data: %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d!\n",
-			sensor_data[0],sensor_data[1],sensor_data[2],sensor_data[3],
-			sensor_data[4],sensor_data[5],sensor_data[6],sensor_data[7],
-			sensor_data[8],sensor_data[9],sensor_data[10],sensor_data[11]);
-	}	
-#endif
-
-}
-
-// M-sensor daemon application have set the sng mode
 static int AKECS_GetData(char *rbuf, int size)
 {
-	char temp;
-	int loop_i,ret;
-#if DEBUG	
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-#endif
-
-	if(size < SENSOR_DATA_SIZE)
-	{
-		printk(KERN_ERR "buff size is too small %d!\n", size);
-		return -1;
-	}
+	int ret;
+	int count = 1;
 	
-	memset(rbuf, 0, SENSOR_DATA_SIZE);
-	rbuf[0] = AK8975_REG_ST1;
-
-	for(loop_i = 0; loop_i < AKM8975_RETRY_COUNT; loop_i++)
-	{
-		if(ret = AKI2C_RxData(rbuf, 1))
-		{
-			printk(KERN_ERR "read ST1 resigster failed!\n");
-			return -1;
-		}
-		
-		if((rbuf[0] & 0x01) == 0x01)
-		{
-			break;
-		}
-		msleep(10);
-		rbuf[0] = AK8975_REG_ST1;
+#ifdef AKM8975_DEBUG
+	/* This function is not exposed, so parameters 
+	 should be checked internally.*/
+	if ((rbuf == NULL) || (size < SENSOR_DATA_SIZE)) {
+		return -EINVAL;
 	}
+#endif
 
-	if(loop_i >= AKM8975_RETRY_COUNT)
-	{
-		printk(KERN_ERR "Data read retry larger the max count!\n");
-		if(0 ==factory_mode)
-		{
-		  return -1;//if return we can not get data at factory mode
+#ifdef AKM8975_USING_IRQ
+	wait_event_interruptible_timeout(data_ready_wq,
+									 atomic_read(&data_ready), 1000);
+	if (!atomic_read(&data_ready)) {
+		AKMDBG("%s: data_ready is not set.", __func__);
+		if (!atomic_read(&suspend_flag)) {
+			AKMDBG("%s: suspend_flag is not set.", __func__);
+			failure_count++;
+			if (failure_count >= MAX_FAILURE_COUNT) {
+				printk(KERN_ERR
+				       "AKM8975 AKECS_GetData: successive %d failure.\n",
+				       failure_count);
+				atomic_set(&open_flag, -1);
+				wake_up(&open_wq);
+				failure_count = 0;
+			}
 		}
-	}
-
-	temp = rbuf[0];
-
-	rbuf[1]= AK8975_REG_HXL;
-	ret = AKI2C_RxData(&rbuf[1], SENSOR_DATA_SIZE -1);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "AKM8975 akm8975_work_func: I2C failed\n");
 		return -1;
-	}
-	rbuf[0] = temp;
+	}		
+
 	mutex_lock(&sense_data_mutex);
-	memcpy(sense_data, rbuf, sizeof(sense_data));	
+	memcpy(rbuf, sense_data, size);
+	atomic_set(&data_ready, 0);
 	mutex_unlock(&sense_data_mutex);
-
-#if DEBUG
-	if(atomic_read(&data->trace) & AMK_DATA_DEBUG)
-	{
-		AKMDBG("Get device data: %d, %d, %d, %d , %d, %d, %d, %d!\n", 
-			sense_data[0],sense_data[1],sense_data[2],sense_data[3],
-			sense_data[4],sense_data[5],sense_data[6],sense_data[7]);
+	
+	failure_count = 0;
+#else	
+	// set single measure mode
+//	AKECS_SetMode(AK8975_MODE_SNG_MEASURE);		
+	
+	mdelay(10);
+	
+	// read data
+	rbuf[0] = AK8975_REG_ST1;
+	ret = AKI2C_RxData(rbuf, size);
+	if (ret < 0) {
+		printk(KERN_ERR "AKM8975 AKECS_GetData: I2C failed\n");
+		return -1;
 	}
+	
+	/* Check ST bit */
+	if ((rbuf[0] & 0x01) != 0x01) {
+		printk(KERN_ERR "AKM8975 AKECS_GetData: ST is not set. DERR = %d\n", (rbuf[7] & 0x04)>>2);			
+	}	
+	
 #endif
-
 	return 0;
 }
 
-// Get Msensor Raw data
-static int AKECS_GetRawData(char *rbuf, int size)
+static void AKECS_SetYPR(short *rbuf)
 {
-	char strbuf[SENSOR_DATA_SIZE];
-	s16 data[3];
-	if(atomic_read(&open_flag) == 0)
-	{
-		AKECS_SetMode_SngMeasure();
-		msleep(10);
-	}
-
-	AKECS_GetData(strbuf, SENSOR_DATA_SIZE);
-	data[0] = (s16)(strbuf[1] | (strbuf[2] << 8));
-	data[1] = (s16)(strbuf[3] | (strbuf[4] << 8));
-	data[2] = (s16)(strbuf[5] | (strbuf[6] << 8));
-	
-	sprintf(rbuf, "%x %x %x", data[0], data[1], data[2]);
-
-	return 0;
-
+	struct akm8975_data *data = i2c_get_clientdata(this_client);
+#if AKM8975_DEBUG_DATA
+	printk(KERN_INFO "AKM8975 %s:\n", __func__);
+	printk(KERN_INFO "  yaw =%6d, pitch =%6d, roll =%6d\n",
+		   rbuf[0], rbuf[1], rbuf[2]);
+	printk(KERN_INFO "  tmp =%6d, m_stat =%6d, g_stat =%6d\n",
+		   rbuf[3], rbuf[4], rbuf[5]);
+	printk(KERN_INFO "  Acceleration[LSB]: %6d,%6d,%6d\n",
+	       rbuf[6], rbuf[7], rbuf[8]);
+	printk(KERN_INFO "  Geomagnetism[LSB]: %6d,%6d,%6d\n",
+	       rbuf[9], rbuf[10], rbuf[11]);
+#endif
+	/* Report magnetic sensor information */
+	if (atomic_read(&m_flag)) {
+		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
+		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
+		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
+		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
+	}
+	
+	/* Report acceleration sensor information */
+	if (atomic_read(&a_flag)) {
+		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
+		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
+		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
+		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
+	}
+	
+	/* Report magnetic vector information */
+	if (atomic_read(&mv_flag)) {
+		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
+	}
+
+	/* Report proximity information */
+	if (atomic_read(&p_flag)) {
+#ifdef CONFIG_OPTICAL_CAPELLA_TRITON
+			rbuf[12]=cm3663_get_proximity_value();
+#else
+		rbuf[12]=gp2a_get_proximity_value();
+#endif
+		input_report_abs(data->input_dev, ABS_DISTANCE, rbuf[12]);
+		printk("Proximity = %d\n", rbuf[12]);
+	}	
+	input_sync(data->input_dev);
 }
 
-
 static int AKECS_GetOpenStatus(void)
 {
 	wait_event_interruptible(open_wq, (atomic_read(&open_flag) != 0));
@@ -570,1345 +399,670 @@
 	return atomic_read(&open_flag);
 }
 
-/*
 static void AKECS_CloseDone(void)
 {
 	atomic_set(&m_flag, 1);
 	atomic_set(&a_flag, 1);
 	atomic_set(&mv_flag, 1);
 }
-*/
 
-
-/*----------------------------------------------------------------------------*/
-static int akm8975_ReadChipInfo(char *buf, int bufsize)
+/***** akm_aot functions ***************************************/
+static int akm_aot_open(struct inode *inode, struct file *file)
 {
-	if((!buf)||(bufsize <= AKM8975_BUFSIZE -1))
-	{
-		return -1;
-	}
-	if(!this_client)
-	{
-		*buf = 0;
-		return -2;
-	}
+	int ret = -1;
 
-	sprintf(buf, "akm8975 Chip");
-	return 0;
-}
-
-/*----------------------------shipment test------------------------------------------------*/
-
-static int TEST_DATA(const char testno[], 
-		  const char testname[],
-          const int testdata, 
-		  const int lolimit, 
-		  const int hilimit,
-          int * pf_total)
-{
-	int pf;                     //Pass;1, Fail;-1
-	
-	if ((testno == NULL) && (strncmp(testname, "START", 5) == 0)) {
-		// Display header
-		AKMDBG( "--------------------------------------------------------------------\n");
-		AKMDBG( " Test No. Test Name    Fail    Test Data    [      Low         High]\n");
-		AKMDBG( "--------------------------------------------------------------------\n");
-		
-		pf = 1;
-	} else if ((testno == NULL) && (strncmp(testname, "END", 3) == 0)) {
-		// Display result
-		AKMDBG( "--------------------------------------------------------------------\n");
-		if (*pf_total == 1) {
-			AKMDBG("Factory shipment test was passed.\n\n");
-		} else {
-			AKMDBG("Factory shipment test was failed.\n\n");
-		}
-		
-		pf = 1;
-	} else {
-		if ((lolimit <= testdata) && (testdata <= hilimit)) {
-			//Pass
-			pf = 1;
-		} else {
-			//Fail
-			pf = -1;
+	AKMFUNC("akm_aot_open");
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			wake_up(&open_wq);
+			ret = 0;
 		}
-		
-		//display result
-		AKMDBG(" %7s  %-10s      %c    %9d    [%9d    %9d]\n", 
-				 testno, testname, ((pf == 1) ? ('.') : ('F')), testdata,
-				 lolimit, hilimit);
-	}
-	
-	//Pass/Fail check
-	if (*pf_total != 0) {
-		if ((*pf_total == 1) && (pf == 1)) {
-			*pf_total = 1;            //Pass
-		} else {
-			*pf_total = -1;           //Fail
-		}
-	}
-	return pf;
-}
-
-
-static int FctShipmntTestProcess_Body()
-{
-	int   pf_total;  //p/f flag for this subtest
-	char    i2cData[16];
-	int   hdata[3];
-	int   asax;
-	int   asay;
-	int   asaz;
-	
-	//***********************************************
-	//  Reset Test Result
-	//***********************************************
-	pf_total = 1;
-	
-	//***********************************************
-	//  Step1
-	//***********************************************
-	
-	// Set to PowerDown mode 
-	if (AKECS_SetMode(AK8975_MODE_POWERDOWN) < 0) {
-		AKMDBG("%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// When the serial interface is SPI,
-	// write "00011011" to I2CDIS register(to disable I2C,).
-	if(CSPEC_SPI_USE == 1){
-		i2cData[0] = AK8975_REG_I2CDIS;
-		i2cData[1] = 0x1B;
-		if (AKI2C_TxData(i2cData, 2) < 0) {
-			DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-			return 0;
-		}
-	}
-	
-	// Read values from WIA to ASTC.
-	i2cData[0] = AK8975_REG_WIA;
-	if (AKI2C_RxData(i2cData, 7) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// TEST
-	TEST_DATA(TLIMIT_NO_RST_WIA,  TLIMIT_TN_RST_WIA,  (int)i2cData[0],  TLIMIT_LO_RST_WIA,  TLIMIT_HI_RST_WIA,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_INFO, TLIMIT_TN_RST_INFO, (int)i2cData[1],  TLIMIT_LO_RST_INFO, TLIMIT_HI_RST_INFO, &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_ST1,  TLIMIT_TN_RST_ST1,  (int)i2cData[2],  TLIMIT_LO_RST_ST1,  TLIMIT_HI_RST_ST1,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_HXL,  TLIMIT_TN_RST_HXL,  (int)i2cData[3],  TLIMIT_LO_RST_HXL,  TLIMIT_HI_RST_HXL,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_HXH,  TLIMIT_TN_RST_HXH,  (int)i2cData[4],  TLIMIT_LO_RST_HXH,  TLIMIT_HI_RST_HXH,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_HYL,  TLIMIT_TN_RST_HYL,  (int)i2cData[5],  TLIMIT_LO_RST_HYL,  TLIMIT_HI_RST_HYL,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_HYH,  TLIMIT_TN_RST_HYH,  (int)i2cData[6],  TLIMIT_LO_RST_HYH,  TLIMIT_HI_RST_HYH,  &pf_total);
-    // our i2c only most can read 8 byte  at one time ,
-    i2cData[7]= AK8975_REG_HZL;
-	if (AKI2C_RxData((i2cData+7), 6) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	TEST_DATA(TLIMIT_NO_RST_HZL,  TLIMIT_TN_RST_HZL,  (int)i2cData[7],  TLIMIT_LO_RST_HZL,  TLIMIT_HI_RST_HZL,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_HZH,  TLIMIT_TN_RST_HZH,  (int)i2cData[8],  TLIMIT_LO_RST_HZH,  TLIMIT_HI_RST_HZH,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_ST2,  TLIMIT_TN_RST_ST2,  (int)i2cData[9],  TLIMIT_LO_RST_ST2,  TLIMIT_HI_RST_ST2,  &pf_total);
-	TEST_DATA(TLIMIT_NO_RST_CNTL, TLIMIT_TN_RST_CNTL, (int)i2cData[10], TLIMIT_LO_RST_CNTL, TLIMIT_HI_RST_CNTL, &pf_total);
-	// i2cData[11] is BLANK.
-	TEST_DATA(TLIMIT_NO_RST_ASTC, TLIMIT_TN_RST_ASTC, (int)i2cData[12], TLIMIT_LO_RST_ASTC, TLIMIT_HI_RST_ASTC, &pf_total);
-	
-	// Read values from I2CDIS.
-	i2cData[0] = AK8975_REG_I2CDIS;
-	if (AKI2C_RxData(i2cData, 1) < 0 ) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	if(CSPEC_SPI_USE == 1){
-		TEST_DATA(TLIMIT_NO_RST_I2CDIS, TLIMIT_TN_RST_I2CDIS, (int)i2cData[0], TLIMIT_LO_RST_I2CDIS_USESPI, TLIMIT_HI_RST_I2CDIS_USESPI, &pf_total);
-	}else{
-		TEST_DATA(TLIMIT_NO_RST_I2CDIS, TLIMIT_TN_RST_I2CDIS, (int)i2cData[0], TLIMIT_LO_RST_I2CDIS_USEI2C, TLIMIT_HI_RST_I2CDIS_USEI2C, &pf_total);
-	}
-	
-	// Set to FUSE ROM access mode
-	if (AKECS_SetMode(AK8975_MODE_FUSE_ACCESS) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// Read values from ASAX to ASAZ
-	i2cData[0] = AK8975_FUSE_ASAX;
-	if (AKI2C_RxData(i2cData, 3) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	asax = (int)i2cData[0];
-	asay = (int)i2cData[1];
-	asaz = (int)i2cData[2];
-#ifdef NOASA
-	if((asax==0)||(asay==0)||(asaz==0)){
-		asax = 128;
-		asay = 128;
-		asaz = 128;
-	}
-#endif
-	
-	// TEST
-	TEST_DATA(TLIMIT_NO_ASAX, TLIMIT_TN_ASAX, asax, TLIMIT_LO_ASAX, TLIMIT_HI_ASAX, &pf_total);
-	TEST_DATA(TLIMIT_NO_ASAY, TLIMIT_TN_ASAY, asay, TLIMIT_LO_ASAY, TLIMIT_HI_ASAY, &pf_total);
-	TEST_DATA(TLIMIT_NO_ASAZ, TLIMIT_TN_ASAZ, asaz, TLIMIT_LO_ASAZ, TLIMIT_HI_ASAZ, &pf_total);
-	
-	// Read values. CNTL
-	i2cData[0] = AK8975_REG_CNTL;
-	if (AKI2C_RxData(i2cData, 1)< 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// Set to PowerDown mode 
-	if (AKECS_SetMode(AK8975_MODE_POWERDOWN) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// TEST
-	TEST_DATA(TLIMIT_NO_WR_CNTL, TLIMIT_TN_WR_CNTL, (int)i2cData[0], TLIMIT_LO_WR_CNTL, TLIMIT_HI_WR_CNTL, &pf_total);
-
-	
-	//***********************************************
-	//  Step2
-	//***********************************************
-	
-	// Set to SNG measurement pattern (Set CNTL register) 
-	if (AKECS_SetMode(AK8975_MODE_SNG_MEASURE) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// Wait for DRDY pin changes to HIGH.
-	msleep(10);
-	// Get measurement data from AK8975
-	// ST1 + (HXL + HXH) + (HYL + HYH) + (HZL + HZH) + ST2
-	// = 1 + (1 + 1) + (1 + 1) + (1 + 1) + 1 = 8 bytes
-	if (AKECS_GetData(i2cData,SENSOR_DATA_SIZE) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-
-	hdata[0] = (s16)(i2cData[1] | (i2cData[2] << 8));
-	hdata[1] = (s16)(i2cData[3] | (i2cData[4] << 8));
-	hdata[2] = (s16)(i2cData[5] | (i2cData[6] << 8));
-	//hdata[0] = (int)((((uint)(i2cData[2]))<<8)+(uint)(i2cData[1]));
-	//hdata[1] = (int)((((uint)(i2cData[4]))<<8)+(uint)(i2cData[3]));
-	//hdata[2] = (int)((((uint)(i2cData[6]))<<8)+(uint)(i2cData[5]));
-	
-	// TEST
-	TEST_DATA(TLIMIT_NO_SNG_ST1, TLIMIT_TN_SNG_ST1, (int)i2cData[0], TLIMIT_LO_SNG_ST1, TLIMIT_HI_SNG_ST1, &pf_total);
-	TEST_DATA(TLIMIT_NO_SNG_HX, TLIMIT_TN_SNG_HX, hdata[0], TLIMIT_LO_SNG_HX, TLIMIT_HI_SNG_HX, &pf_total);
-	TEST_DATA(TLIMIT_NO_SNG_HY, TLIMIT_TN_SNG_HY, hdata[1], TLIMIT_LO_SNG_HY, TLIMIT_HI_SNG_HY, &pf_total);
-	TEST_DATA(TLIMIT_NO_SNG_HZ, TLIMIT_TN_SNG_HZ, hdata[2], TLIMIT_LO_SNG_HZ, TLIMIT_HI_SNG_HZ, &pf_total);
-	TEST_DATA(TLIMIT_NO_SNG_ST2, TLIMIT_TN_SNG_ST2, (int)i2cData[7], TLIMIT_LO_SNG_ST2, TLIMIT_HI_SNG_ST2, &pf_total);
-	
-	// Generate magnetic field for self-test (Set ASTC register)
-	i2cData[0] = AK8975_REG_ASTC;
-	i2cData[1] = 0x40;
-	if (AKI2C_TxData(i2cData, 2) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// Set to Self-test mode (Set CNTL register)
-	if (AKECS_SetMode(AK8975_MODE_SELF_TEST) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	
-	// Wait for DRDY pin changes to HIGH.
-	msleep(10);
-	// Get measurement data from AK8975
-	// ST1 + (HXL + HXH) + (HYL + HYH) + (HZL + HZH) + ST2
-	// = 1 + (1 + 1) + (1 + 1) + (1 + 1) + 1 = 8Byte
-	if (AKECS_GetData(i2cData,SENSOR_DATA_SIZE) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-		
-	// TEST
-	TEST_DATA(TLIMIT_NO_SLF_ST1, TLIMIT_TN_SLF_ST1, (int)i2cData[0], TLIMIT_LO_SLF_ST1, TLIMIT_HI_SLF_ST1, &pf_total);
-
-	hdata[0] = (s16)(i2cData[1] | (i2cData[2] << 8));
-	hdata[1] = (s16)(i2cData[3] | (i2cData[4] << 8));
-	hdata[2] = (s16)(i2cData[5] | (i2cData[6] << 8));
-	
-	//hdata[0] = (int)((((uint)(i2cData[2]))<<8)+(uint)(i2cData[1]));
-	//hdata[1] = (int)((((uint)(i2cData[4]))<<8)+(uint)(i2cData[3]));
-	//hdata[2] = (int)((((uint)(i2cData[6]))<<8)+(uint)(i2cData[5]));
-	
-	// TEST
-	/*
-	TEST_DATA(
-			  TLIMIT_NO_SLF_RVHX, 
-			  TLIMIT_TN_SLF_RVHX, 
-			  (hdata[0])*((asax - 128)*0.5f/128.0f + 1),
-			  TLIMIT_LO_SLF_RVHX,
-			  TLIMIT_HI_SLF_RVHX,
-			  &pf_total
-			  );
-	
-	TEST_DATA(
-			  TLIMIT_NO_SLF_RVHY,
-			  TLIMIT_TN_SLF_RVHY,
-			  (hdata[1])*((asay - 128)*0.5f/128.0f + 1),
-			  TLIMIT_LO_SLF_RVHY,
-			  TLIMIT_HI_SLF_RVHY,
-			  &pf_total
-			  );
-	
-	TEST_DATA(
-			  TLIMIT_NO_SLF_RVHZ,
-			  TLIMIT_TN_SLF_RVHZ,
-			  (hdata[2])*((asaz - 128)*0.5f/128.0f + 1),
-			  TLIMIT_LO_SLF_RVHZ,
-			  TLIMIT_HI_SLF_RVHZ,
-			  &pf_total
-			  );
-	*/
-	AKMDBG("hdata[0] = %d\n",hdata[0] );
-	AKMDBG("asax = %d\n",asax );
-	TEST_DATA(
-			  TLIMIT_NO_SLF_RVHX, 
-			  TLIMIT_TN_SLF_RVHX, 
-			  (hdata[0])*((asax - 128)/2/128 + 1),
-			  TLIMIT_LO_SLF_RVHX,
-			  TLIMIT_HI_SLF_RVHX,
-			  &pf_total
-			  );
-	
-	TEST_DATA(
-			  TLIMIT_NO_SLF_RVHY,
-			  TLIMIT_TN_SLF_RVHY,
-			  (hdata[1])*((asay - 128)/2/128 + 1),
-			  TLIMIT_LO_SLF_RVHY,
-			  TLIMIT_HI_SLF_RVHY,
-			  &pf_total
-			  );
-	
-	TEST_DATA(
-			  TLIMIT_NO_SLF_RVHZ,
-			  TLIMIT_TN_SLF_RVHZ,
-			  (hdata[2])*((asaz - 128)/2/128 + 1),
-			  TLIMIT_LO_SLF_RVHZ,
-			  TLIMIT_HI_SLF_RVHZ,
-			  &pf_total
-			  );
-	// TEST
-	TEST_DATA(TLIMIT_NO_SLF_ST2, TLIMIT_TN_SLF_ST2, (int)i2cData[7], TLIMIT_LO_SLF_ST2, TLIMIT_HI_SLF_ST2, &pf_total);
-	
-	// Set to Normal mode for self-test.
-	i2cData[0] = AK8975_REG_ASTC;
-	i2cData[1] = 0x00;
-	if (AKI2C_TxData(i2cData, 2) < 0) {
-		DBGPRINT(DBG_LEVEL1, "%s:%d Error.\n", __FUNCTION__, __LINE__);
-		return 0;
-	}
-	AKMDBG("pf_total = %d\n",pf_total );
-	return pf_total;
-}
-
-static ssize_t store_shipment_test(struct device_driver * ddri,char * buf,size_t count)
-{
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-	int layout = 0;
-
-	
-	return count;            
-}
-
-static ssize_t show_shipment_test(struct device_driver *ddri, char *buf)
-{
-	char result[10];
-	int res = 0;
-	res = FctShipmntTestProcess_Body();
-	if(1 == res)
-	{
-	   AKMDBG("shipment_test pass\n");
-	   strcpy(result,"y");
-	}
-	else if(-1 == res)
-	{
-	   AKMDBG("shipment_test fail\n");
-	   strcpy(result,"n");
-	}
-	else
-	{
-	  AKMDBG("shipment_test NaN\n");
-	  strcpy(result,"NaN");
 	}
-	
-	return sprintf(buf, "%s\n", result);        
-}
-
-static ssize_t show_daemon_name(struct device_driver *ddri, char *buf)
-{
-	char strbuf[AKM8975_BUFSIZE];
-	sprintf(strbuf, "akmd8975");
-	return sprintf(buf, "%s", strbuf);		
+	return ret;
 }
 
-static ssize_t show_chipinfo_value(struct device_driver *ddri, char *buf)
-{
-	char strbuf[AKM8975_BUFSIZE];
-	akm8975_ReadChipInfo(strbuf, AKM8975_BUFSIZE);
-	return sprintf(buf, "%s\n", strbuf);        
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_sensordata_value(struct device_driver *ddri, char *buf)
+static int akm_aot_release(struct inode *inode, struct file *file)
 {
-
-	char sensordata[SENSOR_DATA_SIZE];
-	char strbuf[AKM8975_BUFSIZE];
-	if(atomic_read(&open_flag) == 0)
-	{
-		AKECS_SetMode_SngMeasure();
-		msleep(10);
-		AKECS_GetData(sensordata, SENSOR_DATA_SIZE);
-	}
-	else
-	{
-		mutex_lock(&sense_data_mutex);
-		memcpy(sensordata, sense_data, sizeof(sensordata));	
-		mutex_unlock(&sense_data_mutex);
-	}
-
-	
-	
-	sprintf(strbuf, "%d %d %d %d %d %d %d %d\n", sensordata[0],sensordata[1],sensordata[2],
-		sensordata[3],sensordata[4],sensordata[5],sensordata[6],sensordata[7]);
-
-	return sprintf(buf, "%s\n", strbuf);
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_posturedata_value(struct device_driver *ddri, char *buf)
-{
-	short tmp[3];
-	char strbuf[AKM8975_BUFSIZE];
-	tmp[0] = sensor_data[0] * CONVERT_O / CONVERT_O_DIV;				
-	tmp[1] = sensor_data[1] * CONVERT_O / CONVERT_O_DIV;
-	tmp[2] = sensor_data[2] * CONVERT_O / CONVERT_O_DIV;
-	sprintf(strbuf, "%d, %d, %d\n", tmp[0],tmp[1], tmp[2]);
-		
-	return sprintf(buf, "%s\n", strbuf);;           
+	AKMFUNC("akm_aot_release");
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+	wake_up(&open_wq);
+	return 0;
 }
 
-/*----------------------------------------------------------------------------*/
-static ssize_t show_layout_value(struct device_driver *ddri, char *buf)
+static int
+akm_aot_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
 {
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-
-	return sprintf(buf, "(%d, %d)\n[%+2d %+2d %+2d]\n[%+2d %+2d %+2d]\n",
-		data->hw->direction,atomic_read(&data->layout),	data->cvt.sign[0], data->cvt.sign[1],
-		data->cvt.sign[2],data->cvt.map[0], data->cvt.map[1], data->cvt.map[2]);            
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t store_layout_value(struct device_driver *ddri, char *buf, size_t count)
-{
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-	int layout = 0;
-
-	if(1 == sscanf(buf, "%d", &layout))
-	{
-		atomic_set(&data->layout, layout);
-		if(!hwmsen_get_convert(layout, &data->cvt))
-		{
-			printk(KERN_ERR "HWMSEN_GET_CONVERT function error!\r\n");
-		}
-		else if(!hwmsen_get_convert(data->hw->direction, &data->cvt))
-		{
-			printk(KERN_ERR "invalid layout: %d, restore to %d\n", layout, data->hw->direction);
-		}
-		else
-		{
-			printk(KERN_ERR "invalid layout: (%d, %d)\n", layout, data->hw->direction);
-			hwmsen_get_convert(0, &data->cvt);
-		}
-	}
-	else
-	{
-		printk(KERN_ERR "invalid format = '%s'\n", buf);
-	}
+	void __user *argp = (void __user *)arg;
+	short flag;
 	
-	return count;            
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_status_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-	ssize_t len = 0;
-
-	if(data->hw)
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: %d %d (%d %d)\n", 
-			data->hw->i2c_num, data->hw->direction, data->hw->power_id, data->hw->power_vol);
-	}
-	else
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: NULL\n");
+	switch (cmd) {
+		case ECS_IOCTL_APP_SET_MFLAG:
+		case ECS_IOCTL_APP_SET_AFLAG:
+		case ECS_IOCTL_APP_SET_MVFLAG:
+		case ECS_IOCTL_APP_SET_PFLAG:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			if (flag < 0 || flag > 1) {
+				return -EINVAL;
+			}
+			break;
+		case ECS_IOCTL_APP_SET_DELAY:
+			if (copy_from_user(&flag, argp, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
 	}
 	
-	len += snprintf(buf+len, PAGE_SIZE-len, "OPEN: %d\n", atomic_read(&dev_open_count));
-	return len;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_trace_value(struct device_driver *ddri, char *buf)
-{
-	ssize_t res;
-	struct akm8975_i2c_data *obj = i2c_get_clientdata(this_client);
-	if(NULL == obj)
-	{
-		printk(KERN_ERR "akm8975_i2c_data is null!!\n");
-		return 0;
-	}	
-	
-	res = snprintf(buf, PAGE_SIZE, "0x%04X\n", atomic_read(&obj->trace));     
-	return res;    
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t store_trace_value(struct device_driver *ddri, char *buf, size_t count)
-{
-	struct akm8975_i2c_data *obj = i2c_get_clientdata(this_client);
-	int trace;
-	if(NULL == obj)
-	{
-		printk(KERN_ERR "akm8975_i2c_data is null!!\n");
-		return 0;
-	}
-	
-	if(1 == sscanf(buf, "0x%x", &trace))
-	{
-		atomic_set(&obj->trace, trace);
-	}
-	else 
-	{
-		printk(KERN_ERR "invalid content: '%s', length = %d\n", buf, count);
-	}
-	
-	return count;    
-}
-/*----------------------------------------------------------------------------*/
-static DRIVER_ATTR(daemon,      S_IRUGO, show_daemon_name, NULL);
-static DRIVER_ATTR(shipmenttest,S_IRUGO | S_IWUSR, show_shipment_test, store_shipment_test);
-static DRIVER_ATTR(chipinfo,    S_IRUGO, show_chipinfo_value, NULL);
-static DRIVER_ATTR(sensordata,  S_IRUGO, show_sensordata_value, NULL);
-static DRIVER_ATTR(posturedata, S_IRUGO, show_posturedata_value, NULL);
-static DRIVER_ATTR(layout,      S_IRUGO | S_IWUSR, show_layout_value, store_layout_value );
-static DRIVER_ATTR(status,      S_IRUGO, show_status_value, NULL);
-static DRIVER_ATTR(trace,       S_IRUGO | S_IWUSR, show_trace_value, store_trace_value );
-/*----------------------------------------------------------------------------*/
-static struct driver_attribute *akm8975_attr_list[] = {
-    &driver_attr_daemon,
-    &driver_attr_shipmenttest,
-	&driver_attr_chipinfo,
-	&driver_attr_sensordata,
-	&driver_attr_posturedata,
-	&driver_attr_layout,
-	&driver_attr_status,
-	&driver_attr_trace,
-};
-/*----------------------------------------------------------------------------*/
-static int akm8975_create_attr(struct device_driver *driver) 
-{
-	int idx, err = 0;
-	int num = (int)(sizeof(akm8975_attr_list)/sizeof(akm8975_attr_list[0]));
-	if (driver == NULL)
-	{
-		return -EINVAL;
-	}
-
-	for(idx = 0; idx < num; idx++)
-	{
-		if(err = driver_create_file(driver, akm8975_attr_list[idx]))
-		{            
-			printk(KERN_ERR "driver_create_file (%s) = %d\n", akm8975_attr_list[idx]->attr.name, err);
+	switch (cmd) {
+		case ECS_IOCTL_APP_SET_MFLAG:
+			atomic_set(&m_flag, flag);
+			AKMDBG("MFLAG is set to %d", flag);
 			break;
-		}
-	}    
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-static int akm8975_delete_attr(struct device_driver *driver)
-{
-	int idx ,err = 0;
-	int num = (int)(sizeof(akm8975_attr_list)/sizeof(akm8975_attr_list[0]));
-
-	if(driver == NULL)
-	{
-		return -EINVAL;
+		case ECS_IOCTL_APP_GET_MFLAG:
+			flag = atomic_read(&m_flag);
+			break;
+		case ECS_IOCTL_APP_SET_AFLAG:
+			atomic_set(&a_flag, flag);
+			AKMDBG("AFLAG is set to %d", flag);
+			break;
+		case ECS_IOCTL_APP_GET_AFLAG:
+			flag = atomic_read(&a_flag);
+			break;
+		case ECS_IOCTL_APP_SET_MVFLAG:
+			atomic_set(&mv_flag, flag);
+			AKMDBG("MVFLAG is set to %d", flag);
+			break;
+		case ECS_IOCTL_APP_GET_MVFLAG:
+			flag = atomic_read(&mv_flag);
+			break;
+		case ECS_IOCTL_APP_SET_PFLAG:
+			atomic_set(&p_flag, flag);
+			break;
+		case ECS_IOCTL_APP_GET_PFLAG:
+			flag = atomic_read(&p_flag);
+			break;
+		case ECS_IOCTL_APP_SET_DELAY:
+			akmd_delay = flag;
+			AKMDBG("Delay is set to %d", flag);
+			break;
+		case ECS_IOCTL_APP_GET_DELAY:
+			flag = akmd_delay;
+			break;
+		default:
+			return -ENOTTY;
 	}
 	
-
-	for(idx = 0; idx < num; idx++)
-	{
-		driver_remove_file(driver, akm8975_attr_list[idx]);
+	switch (cmd) {
+		case ECS_IOCTL_APP_GET_MFLAG:
+		case ECS_IOCTL_APP_GET_AFLAG:
+		case ECS_IOCTL_APP_GET_MVFLAG:
+		case ECS_IOCTL_APP_GET_PFLAG:
+		case ECS_IOCTL_APP_GET_DELAY:
+			if (copy_to_user(argp, &flag, sizeof(flag))) {
+				return -EFAULT;
+			}
+			break;
+		default:
+			break;
 	}
 	
-
-	return err;
+	return 0;
 }
 
-
-/*----------------------------------------------------------------------------*/
-static int akm8975_open(struct inode *inode, struct file *file)
-{    
-	struct akm8975_i2c_data *obj = i2c_get_clientdata(this_client);    
-	int ret = -1;	
-	
-	if(atomic_read(&obj->trace) & AMK_CTR_DEBUG)
-	{
-		AKMDBG("Open device node:akm8975\n");
-	}
-	ret = nonseekable_open(inode, file);
-	
-	return ret;
+/***** akmd functions ********************************************/
+static int akmd_open(struct inode *inode, struct file *file)
+{
+	AKMFUNC("akmd_open");
+	return nonseekable_open(inode, file);
 }
-/*----------------------------------------------------------------------------*/
-static int akm8975_release(struct inode *inode, struct file *file)
+
+static int akmd_release(struct inode *inode, struct file *file)
 {
-	struct akm8975_i2c_data *obj = i2c_get_clientdata(this_client);
-	atomic_dec(&dev_open_count);
-	if(atomic_read(&obj->trace) & AMK_CTR_DEBUG)
-	{
-		AKMDBG("Release device node:akm8975\n");
-	}	
+	AKMFUNC("akmd_release");
+	AKECS_CloseDone();
 	return 0;
 }
-/*----------------------------------------------------------------------------*/
-//static int akm8975_ioctl(struct inode *inode, struct file *file, unsigned int cmd,unsigned long arg)
-static long akm8975_unlocked_ioctl(struct file *file, unsigned int cmd,unsigned long arg)
 
+static int
+akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		   unsigned long arg)
 {
 	void __user *argp = (void __user *)arg;
-		
+	
 	/* NOTE: In this function the size of "char" should be 1-byte. */
 	char sData[SENSOR_DATA_SIZE];/* for GETDATA */
-	char rwbuf[RWBUF_SIZE]; 	/* for READ/WRITE */
-	char buff[AKM8975_BUFSIZE];				/* for chip information */
+	char rwbuf[RWBUF_SIZE];		/* for READ/WRITE */
 	char mode;					/* for SET_MODE*/
-	short value[12];			/* for SET_YPR */
+	short value[13];			/* for SET_YPR */
 	short delay;				/* for GET_DELAY */
-	int status; 				/* for OPEN/CLOSE_STATUS */
-	long ret = -1;				/* Return value. */
-	int layout[3];
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-	hwm_sensor_data* osensor_data;
-	uint32_t enable;
-
-	switch (cmd)
-	{
+	int status;					/* for OPEN/CLOSE_STATUS */
+	int ret = -1;				/* Return value. */
+	/*AKMDBG("%s (0x%08X).", __func__, cmd);*/
+	
+	switch (cmd) {
 		case ECS_IOCTL_WRITE:
-			//AKMFUNC("ECS_IOCTL_WRITE");
-			if(argp == NULL)
-			{
+		case ECS_IOCTL_READ:
+			if (argp == NULL) {
 				AKMDBG("invalid argument.");
 				return -EINVAL;
 			}
-			if(copy_from_user(rwbuf, argp, sizeof(rwbuf)))
-			{
+			if (copy_from_user(&rwbuf, argp, sizeof(rwbuf))) {
 				AKMDBG("copy_from_user failed.");
 				return -EFAULT;
 			}
-
-			if((rwbuf[0] < 2) || (rwbuf[0] > (RWBUF_SIZE-1)))
-			{
+			break;
+		case ECS_IOCTL_SET_MODE:
+			if (argp == NULL) {
 				AKMDBG("invalid argument.");
 				return -EINVAL;
 			}
-			ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
-			if(ret < 0)
-			{
-				return ret;
+			if (copy_from_user(&mode, argp, sizeof(mode))) {
+				AKMDBG("copy_from_user failed.");
+				return -EFAULT;
 			}
 			break;
-			
-		case ECS_IOCTL_READ:
-			//AKMFUNC("ECS_IOCTL_READ");
-			if(argp == NULL)
-			{
+		case ECS_IOCTL_SET_YPR:
+			if (argp == NULL) {
 				AKMDBG("invalid argument.");
 				return -EINVAL;
 			}
-			
-			if(copy_from_user(rwbuf, argp, sizeof(rwbuf)))
-			{
+			if (copy_from_user(&value, argp, sizeof(value))) {
 				AKMDBG("copy_from_user failed.");
 				return -EFAULT;
 			}
-
-			if((rwbuf[0] < 1) || (rwbuf[0] > (RWBUF_SIZE-1)))
-			{
+			break;
+		default:
+			break;
+	}
+	
+	switch (cmd) {
+		case ECS_IOCTL_WRITE:
+			AKMFUNC("IOCTL_WRITE");
+			if ((rwbuf[0] < 2) || (rwbuf[0] > (RWBUF_SIZE-1))) {
 				AKMDBG("invalid argument.");
 				return -EINVAL;
 			}
-			ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
-			if (ret < 0)
-			{
+			ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
+			if (ret < 0) {
 				return ret;
 			}
-			if(copy_to_user(argp, rwbuf, rwbuf[0]+1))
-			{
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
 			break;
-			
-		case ECS_IOCTL_SET_MODE:
-			//AKMFUNC("ECS_IOCTL_SET_MODE");
-			if(argp == NULL)
-			{
+		case ECS_IOCTL_READ:
+			AKMFUNC("IOCTL_READ");
+			if ((rwbuf[0] < 1) || (rwbuf[0] > (RWBUF_SIZE-1))) {
 				AKMDBG("invalid argument.");
 				return -EINVAL;
 			}
-			if(copy_from_user(&mode, argp, sizeof(mode)))
-			{
-				AKMDBG("copy_from_user failed.");
-				return -EFAULT;
+			ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
+			if (ret < 0) {
+				return ret;
 			}
+			break;
+		case ECS_IOCTL_SET_MODE:
+			AKMFUNC("IOCTL_SET_MODE");
 			ret = AKECS_SetMode(mode);
-			if(ret < 0)
-			{
+			if (ret < 0) {
 				return ret;
 			}
 			break;
-
 		case ECS_IOCTL_GETDATA:
-			//AKMFUNC("ECS_IOCTL_GETDATA");
+			AKMFUNC("IOCTL_GET_DATA");
 			ret = AKECS_GetData(sData, SENSOR_DATA_SIZE);
-			if(ret < 0)
-			{
+			if (ret < 0) {
 				return ret;
 			}
-
-			if(copy_to_user(argp, sData, sizeof(sData)))
-			{
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
 			break;
-			
 		case ECS_IOCTL_SET_YPR:
-			//AKMFUNC("ECS_IOCTL_SET_YPR");
-			if(argp == NULL)
-			{
-				AKMDBG("invalid argument.");
-				return -EINVAL;
-			}
-			if(copy_from_user(value, argp, sizeof(value)))
-			{
-				AKMDBG("copy_from_user failed.");
-				return -EFAULT;
-			}
-			AKECS_SaveData(value);
+			AKECS_SetYPR(value);
 			break;
-
 		case ECS_IOCTL_GET_OPEN_STATUS:
-			//AKMFUNC("IOCTL_GET_OPEN_STATUS");
+			AKMFUNC("IOCTL_GET_OPEN_STATUS");
 			status = AKECS_GetOpenStatus();
-			//AKMDBG("AKECS_GetOpenStatus returned (%d)", status);
-			if(copy_to_user(argp, &status, sizeof(status)))
-			{
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
+			AKMDBG("AKECS_GetOpenStatus returned (%d)", status);
 			break;
-			
 		case ECS_IOCTL_GET_CLOSE_STATUS:
-			//AKMFUNC("IOCTL_GET_CLOSE_STATUS");
+			AKMFUNC("IOCTL_GET_CLOSE_STATUS");
 			status = AKECS_GetCloseStatus();
-			//AKMDBG("AKECS_GetCloseStatus returned (%d)", status);
-			if(copy_to_user(argp, &status, sizeof(status)))
-			{
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
-			break;
-			
-		case ECS_IOCTL_GET_OSENSOR_STATUS:
-			//AKMFUNC("ECS_IOCTL_GET_OSENSOR_STATUS");
-			status = atomic_read(&o_flag);
-			if(copy_to_user(argp, &status, sizeof(status)))
-			{
-				AKMDBG("copy_to_user failed.");
-				return -EFAULT;
-			}
+			AKMDBG("AKECS_GetCloseStatus returned (%d)", status);
 			break;
-			
 		case ECS_IOCTL_GET_DELAY:
-			//AKMFUNC("IOCTL_GET_DELAY");
+			AKMFUNC("IOCTL_GET_DELAY");
 			delay = akmd_delay;
-			if(copy_to_user(argp, &delay, sizeof(delay)))
-			{
+			break;
+		default:
+			return -ENOTTY;
+	}
+	
+	switch (cmd) {
+		case ECS_IOCTL_READ:
+			if (copy_to_user(argp, &rwbuf, rwbuf[0]+1)) {
 				AKMDBG("copy_to_user failed.");
 				return -EFAULT;
 			}
 			break;
-
-		case ECS_IOCTL_GET_LAYOUT:
-			layout[0] = 2;
-			layout[1] = atomic_read(&data->layout);
-			layout[2] = 0;
-			if(copy_to_user(argp, layout, sizeof(layout)))
-			{
+		case ECS_IOCTL_GETDATA:
+			if (copy_to_user(argp, &sData, sizeof(sData))) {
 				AKMDBG("copy_to_user failed.");
 				return -EFAULT;
 			}
 			break;
-
-		case MSENSOR_IOCTL_READ_CHIPINFO:
-			if(argp == NULL)
-			{
-				printk(KERN_ERR "IO parameter pointer is NULL!\r\n");
-				break;
-			}
-			
-			akm8975_ReadChipInfo(buff, AKM8975_BUFSIZE);
-			if(copy_to_user(argp, buff, strlen(buff)+1))
-			{
-				return -EFAULT;
-			}                
-			break;
-
-		case MSENSOR_IOCTL_READ_SENSORDATA:			
-			if(argp == NULL)
-			{
-				printk(KERN_ERR "IO parameter pointer is NULL!\r\n");
-				break;    
-			}
-			
-			AKECS_GetRawData(buff, AKM8975_BUFSIZE);
-			
-			if(copy_to_user(argp, buff, strlen(buff)+1))
-			{
-				return -EFAULT;
-			}                
-			break;
-			
-        case MSENSOR_IOCTL_SENSOR_ENABLE:
-			
-			if(argp == NULL)
-			{
-				printk(KERN_ERR "IO parameter pointer is NULL!\r\n");
-				break;
-			}
-			if(copy_from_user(&enable, argp, sizeof(enable)))
-			{
-				AKMDBG("copy_from_user failed.");
+		case ECS_IOCTL_GET_OPEN_STATUS:
+		case ECS_IOCTL_GET_CLOSE_STATUS:
+			if (copy_to_user(argp, &status, sizeof(status))) {
+				AKMDBG("copy_to_user failed.");
 				return -EFAULT;
 			}
-			else
-			{
-			    printk( "MSENSOR_IOCTL_SENSOR_ENABLE enable=%d!\r\n",enable);
-				factory_mode = 1;
-				if(1 == enable)
-				{
-					atomic_set(&o_flag, 1);
-					atomic_set(&open_flag, 1);
-				}
-				else
-				{
-					atomic_set(&o_flag, 0);
-					if(atomic_read(&m_flag) == 0)
-					{
-						atomic_set(&open_flag, 0);
-					}			
-				}
-				wake_up(&open_wq);
-				
-			}
-			
 			break;
-			
-		case MSENSOR_IOCTL_READ_FACTORY_SENSORDATA:			
-			if(argp == NULL)
-			{
-				printk(KERN_ERR "IO parameter pointer is NULL!\r\n");
-				break;    
-			}
-			
-			//AKECS_GetRawData(buff, AKM8975_BUFSIZE);
-			osensor_data = (hwm_sensor_data *)buff;
-		    mutex_lock(&sensor_data_mutex);
-				
-			osensor_data->values[0] = sensor_data[0] * CONVERT_O;
-			osensor_data->values[1] = sensor_data[1] * CONVERT_O;
-			osensor_data->values[2] = sensor_data[2] * CONVERT_O;
-			osensor_data->status = sensor_data[4];
-			osensor_data->value_divide = CONVERT_O_DIV;
-					
-			mutex_unlock(&sensor_data_mutex);
-
-            sprintf(buff, "%x %x %x %x %x", osensor_data->values[0], osensor_data->values[1],
-				osensor_data->values[2],osensor_data->status,osensor_data->value_divide);
-			if(copy_to_user(argp, buff, strlen(buff)+1))
-			{
+		case ECS_IOCTL_GET_DELAY:
+			if (copy_to_user(argp, &delay, sizeof(delay))) {
+				AKMDBG("copy_to_user failed.");
 				return -EFAULT;
-			} 
-			
-			break;
-			
-		default:
-			printk(KERN_ERR "%s not supported = 0x%04x", __FUNCTION__, cmd);
-			return -ENOIOCTLCMD;
-			break;		
-		}
-
-	return 0;    
-}
-/*----------------------------------------------------------------------------*/
-static struct file_operations akm8975_fops = {
-//	.owner = THIS_MODULE,
-	.open = akm8975_open,
-	.release = akm8975_release,
-	.unlocked_ioctl = akm8975_unlocked_ioctl,
-};
-/*----------------------------------------------------------------------------*/
-static struct miscdevice akm8975_device = {
-    .minor = MISC_DYNAMIC_MINOR,
-    .name = "msensor",
-    .fops = &akm8975_fops,
-};
-/*----------------------------------------------------------------------------*/
-int akm8975_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
-{
-	int err = 0;
-	int value, status;
-	hwm_sensor_data* msensor_data;
-	
-#if DEBUG	
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-#endif
-	
-#if DEBUG
-	if(atomic_read(&data->trace) & AMK_FUN_DEBUG)
-	{
-		AKMFUNC("akm8975_operate");
-	}	
-#endif
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				printk(KERN_ERR "Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				value = *(int *)buff_in;
-				if(value <= 20)
-				{
-					akmd_delay = 20;
-				}
-				akmd_delay = value;
-			}	
-			break;
-
-		case SENSOR_ENABLE:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				printk(KERN_ERR "Enable sensor parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				
-				value = *(int *)buff_in;
-
-				if(value == 1)
-				{
-					atomic_set(&m_flag, 1);
-					atomic_set(&open_flag, 1);
-				}
-				else
-				{
-					atomic_set(&m_flag, 0);
-					if(atomic_read(&o_flag) == 0)
-					{
-						atomic_set(&open_flag, 0);
-					}
-				}
-				wake_up(&open_wq);
-				
-				// TODO: turn device into standby or normal mode
-			}
-			break;
-
-		case SENSOR_GET_DATA:
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				printk(KERN_ERR "get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				msensor_data = (hwm_sensor_data *)buff_out;
-				mutex_lock(&sensor_data_mutex);
-				
-				msensor_data->values[0] = sensor_data[9] * CONVERT_M;
-				msensor_data->values[1] = sensor_data[10] * CONVERT_M;
-				msensor_data->values[2] = sensor_data[11] * CONVERT_M;
-				msensor_data->status = sensor_data[4];
-				msensor_data->value_divide = CONVERT_M_DIV;
-					
-				mutex_unlock(&sensor_data_mutex);
-#if DEBUG
-				if(atomic_read(&data->trace) & AMK_HWM_DEBUG)
-				{
-					AKMDBG("Hwm get m-sensor data: %d, %d, %d. divide %d, status %d!\n",
-						msensor_data->values[0],msensor_data->values[1],msensor_data->values[2],
-						msensor_data->value_divide,msensor_data->status);
-				}	
-#endif
 			}
 			break;
 		default:
-			printk(KERN_ERR "msensor operate function no this parameter %d!\n", command);
-			err = -1;
 			break;
 	}
 	
-	return err;
+	return 0;
 }
 
-/*----------------------------------------------------------------------------*/
-int akm8975_orientation_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
+#ifdef AKM8975_USING_IRQ
+static void akm8975_work_func(struct work_struct *work)
 {
-	int err = 0;
-	int value, sample_delay, status;
-	hwm_sensor_data* osensor_data;	
-#if DEBUG	
-	struct i2c_client *client = this_client;  
-	struct akm8975_i2c_data *data = i2c_get_clientdata(client);
-#endif
+	char buffer[SENSOR_DATA_SIZE];
+	int ret;
 	
-#if DEBUG
-	if(atomic_read(&data->trace) & AMK_FUN_DEBUG)
-	{
-		AKMFUNC("akm8975_orientation_operate");
-	}	
-#endif
-
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				printk(KERN_ERR "Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				value = *(int *)buff_in;
-				if(value <= 20)
-				{
-					akmd_delay = 20;
-				}
-				akmd_delay = value;
-			}	
-			break;
-
-		case SENSOR_ENABLE:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				printk(KERN_ERR "Enable sensor parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				
-				value = *(int *)buff_in;
-
-				if(value == 1)
-				{
-					atomic_set(&o_flag, 1);
-					atomic_set(&open_flag, 1);
-				}
-				else
-				{
-					atomic_set(&o_flag, 0);
-					if(atomic_read(&m_flag) == 0)
-					{
-						atomic_set(&open_flag, 0);
-					}									
-				}	
-				wake_up(&open_wq);
-			}
-			break;
-
-		case SENSOR_GET_DATA:
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				printk(KERN_ERR "get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				osensor_data = (hwm_sensor_data *)buff_out;
-				mutex_lock(&sensor_data_mutex);
-				
-				osensor_data->values[0] = sensor_data[0] * CONVERT_O;
-				osensor_data->values[1] = sensor_data[1] * CONVERT_O;
-				osensor_data->values[2] = sensor_data[2] * CONVERT_O;
-				osensor_data->status = sensor_data[4];
-				osensor_data->value_divide = CONVERT_O_DIV;
-					
-				mutex_unlock(&sensor_data_mutex);
-#if DEBUG
-			if(atomic_read(&data->trace) & AMK_HWM_DEBUG)
-			{
-				AKMDBG("Hwm get o-sensor data: %d, %d, %d. divide %d, status %d!\n",
-					osensor_data->values[0],osensor_data->values[1],osensor_data->values[2],
-					osensor_data->value_divide,osensor_data->status);
-			}	
-#endif
-			}
-			break;
-		default:
-			printk(KERN_ERR "gsensor operate function no this parameter %d!\n", command);
-			err = -1;
-			break;
+	memset(buffer, 0, SENSOR_DATA_SIZE);
+	buffer[0] = AK8975_REG_ST1;
+	ret = AKI2C_RxData(buffer, SENSOR_DATA_SIZE);
+	if (ret < 0) {
+		printk(KERN_ERR "AKM8975 akm8975_work_func: I2C failed\n");
+		return;
+	}
+	/* Check ST bit */
+	if ((buffer[0] & 0x01) != 0x01) {
+		printk(KERN_ERR "AKM8975 akm8975_work_func: ST is not set\n");
+		return;
 	}
 	
-	return err;
+	mutex_lock(&sense_data_mutex);
+	memcpy(sense_data, buffer, SENSOR_DATA_SIZE);
+	atomic_set(&data_ready, 1);
+	wake_up(&data_ready_wq);
+	mutex_unlock(&sense_data_mutex);
+	
+	enable_irq(this_client->irq);
+	
+	AKMFUNC("akm8975_work_func");
 }
 
-/*----------------------------------------------------------------------------*/
-#ifndef	CONFIG_HAS_EARLYSUSPEND
-/*----------------------------------------------------------------------------*/
-static int akm8975_suspend(struct i2c_client *client, pm_message_t msg) 
-{
-	int err;
-	struct akm8975_i2c_data *obj = i2c_get_clientdata(client)
-	    
-
-	if(msg.event == PM_EVENT_SUSPEND)
-	{
-		akm8975_power(obj->hw, 0);
-	}
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int akm8975_resume(struct i2c_client *client)
+static irqreturn_t akm8975_interrupt(int irq, void *dev_id)
 {
-	int err;
-	struct akm8975_i2c_data *obj = i2c_get_clientdata(client)
+	struct akm8975_data *data = dev_id;
+	AKMFUNC("akm8975_interrupt");
+	disable_irq(this_client->irq);
+	schedule_work(&data->work);
+	return IRQ_HANDLED;
+}
+#endif
 
+#if 0
+static void akm8975_early_suspend(struct early_suspend *handler)
+{
+	AKMFUNC("akm8975_early_suspend");
+	atomic_set(&suspend_flag, 1);
+	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
+	atomic_set(&open_flag, 0);
+	wake_up(&open_wq);
+	disable_irq(this_client->irq);
+	AKMDBG("suspended with flag=%d", 
+	       atomic_read(&reserve_open_flag));
+}
 
-	akm8975_power(obj->hw, 1);
+static void akm8975_early_resume(struct early_suspend *handler)
+{
+	AKMFUNC("akm8975_early_resume");
+	enable_irq(this_client->irq);
+	atomic_set(&suspend_flag, 0);
+	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
+	wake_up(&open_wq);
+	AKMDBG("resumed with flag=%d", 
+	       atomic_read(&reserve_open_flag));
+}
+#else
+static int akm8975_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	AKMFUNC("akm8975_early_suspend");
+	atomic_set(&suspend_flag, 1);
+	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
+	atomic_set(&open_flag, 0);
+	wake_up(&open_wq);
+#ifdef AKM8975_USING_IRQ
+	disable_irq(this_client->irq);
+#endif
+	AKMDBG("suspended with flag=%d", 
+	       atomic_read(&reserve_open_flag));
+		   
+	AKECS_SetMode(AK8975_MODE_POWERDOWN);		  
 	
-
 	return 0;
 }
-/*----------------------------------------------------------------------------*/
-#else /*CONFIG_HAS_EARLY_SUSPEND is defined*/
-/*----------------------------------------------------------------------------*/
-static void akm8975_early_suspend(struct early_suspend *h) 
-{
-	struct akm8975_i2c_data *obj = container_of(h, struct akm8975_i2c_data, early_drv);   
-	int err;
-   
-
-	if(NULL == obj)
-	{
-		printk(KERN_ERR "null pointer!!\n");
-		return;
-	}
-	       
-}
-/*----------------------------------------------------------------------------*/
-static void akm8975_late_resume(struct early_suspend *h)
+
+static int akm8975_resume(struct i2c_client *client)
 {
-	struct akm8975_i2c_data *obj = container_of(h, struct akm8975_i2c_data, early_drv);         
-	int err;
+	AKMFUNC("akm8975_early_resume");
+#ifdef AKM8975_USING_IRQ
+	enable_irq(this_client->irq);
+#endif
+	atomic_set(&suspend_flag, 0);
+	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
+	wake_up(&open_wq);
+	AKMDBG("resumed with flag=%d", 
+	       atomic_read(&reserve_open_flag));
+		   
+	AKECS_SetMode(AK8975_MODE_SNG_MEASURE);
+	
+	return 0;
+}
+#endif
 
+/*********************************************/
+static struct file_operations akmd_fops = {
+	.owner = THIS_MODULE,
+	.open = akmd_open,
+	.release = akmd_release,
+	.ioctl = akmd_ioctl,
+};
 
-	if(NULL == obj)
-	{
-		printk(KERN_ERR "null pointer!!\n");
-		return;
-	}
+static struct file_operations akm_aot_fops = {
+	.owner = THIS_MODULE,
+	.open = akm_aot_open,
+	.release = akm_aot_release,
+	.ioctl = akm_aot_ioctl,
+};
 
-	akm8975_power(obj->hw, 1);
+static struct miscdevice akmd_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8975_dev",
+	.fops = &akmd_fops,
+};
+
+static struct miscdevice akm_aot_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8975_aot",
+	.fops = &akm_aot_fops,
+};
+
+// Factory TEST
+static ssize_t ak_fs_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int count = 0;
+	char buffer[SENSOR_DATA_SIZE];
+	short mag_x, mag_y, mag_z;	
+	
+	memset(buffer, 0, SENSOR_DATA_SIZE);	
+	
+	AKECS_GetData(buffer, SENSOR_DATA_SIZE);
+
+	if ((buffer[0] & 0x01)) {	
+		mag_x = (short)( (buffer[2] << 8) | buffer[1] );
+		mag_y = (short)( (buffer[4] << 8) | buffer[3] );
+		mag_z = (short)( (buffer[6] << 8) | buffer[5] )	;
+		
+		printk("[ak_fs_read] buf[0] = %d, buf[1] = %d, buf[2] = %d, buf[3] = %d, buf[4] = %d, buf[5] = %d, buf[6] = %d, buf[7] = %d\n", 
+		buffer[0], buffer[1], buffer[2], buffer[3], buffer[4],  buffer[5], buffer[6], buffer[7]);
+		
+		printk("[%s] x: %d, y: %d, z: %d\n", __func__, mag_x, mag_y, mag_z);
 	
+		count = sprintf(buf,"x: %d, y: %d, z: %d\n", mag_x, mag_y, mag_z);
+	
+		printk("[%s]: successfull\n", __func__);
+	}	
+	else
+		printk("[%s]: data is not ready\n", __func__);
+
+	return count;
 }
-/*----------------------------------------------------------------------------*/
-#endif /*CONFIG_HAS_EARLYSUSPEND*/
-/*----------------------------------------------------------------------------*/
-static int akm8975_i2c_detect(struct i2c_client *client, int kind, struct i2c_board_info *info) 
-{    
-	strcpy(info->type, AKM8975_DEV_NAME);
-	return 0;
+
+static ssize_t ak_fs_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	//buf[size]=0;
+	printk("input data --> %s\n", buf);
+
+	return size;
 }
+static DEVICE_ATTR(ak_file, S_IRUGO | S_IWUSR | S_IWOTH | S_IXOTH, ak_fs_read, ak_fs_write);
+//TEST 
 
-/*----------------------------------------------------------------------------*/
-static int akm8975_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+/*********************************************/
+int akm8975_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
-	struct i2c_client *new_client;
-	struct akm8975_i2c_data *data;
+	struct akm8975_data *akm;
 	int err = 0;
-	struct hwmsen_object sobj_m, sobj_o;
+	
+	AKMFUNC("akm8975_probe");
 
-	if(!(data = kmalloc(sizeof(struct akm8975_i2c_data), GFP_KERNEL)))
-	{
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: check_functionality failed.\n");
+		err = -ENODEV;
+		goto exit0;
+	}
+	
+	/* Allocate memory for driver data */
+	akm = kzalloc(sizeof(struct akm8975_data), GFP_KERNEL);
+	if (!akm) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: memory allocation failed.\n");
 		err = -ENOMEM;
-		goto exit;
+		goto exit1;
 	}
-	memset(data, 0, sizeof(struct akm8975_i2c_data));
-	data->hw = get_cust_mag_hw();	
+
+#ifdef AKM8975_USING_IRQ
+	INIT_WORK(&akm->work, akm8975_work_func);
+#endif
+	i2c_set_clientdata(client, akm);
 	
-	atomic_set(&data->layout, data->hw->direction);
-	atomic_set(&data->trace, 0);
+#ifdef AKM8975_USING_IRQ
+	/* Check platform data*/	
+	if (client->dev.platform_data == NULL) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: platform data is NULL\n");
+		err = -ENOMEM;
+		goto exit2;
+	}	
 	
-	mutex_init(&sense_data_mutex);
-	mutex_init(&sensor_data_mutex);
+	/* Copy to global variable */
+	pdata = client->dev.platform_data;
+#endif
 	
-	init_waitqueue_head(&data_ready_wq);
-	init_waitqueue_head(&open_wq);
-
-	data->client = client;
-	new_client = data->client;
-	i2c_set_clientdata(new_client, data);
+	this_client = client;
 	
-	this_client = new_client;	
-
-     printk(KERN_ERR " AKM8975 akm8975_probe: befor init prob \n");
 	/* Check connection */
 	err = AKECS_CheckDevice();
-	if(err < 0)
-	{
-		printk(KERN_ERR "AKM8975 akm8975_probe: check device connect error\n");
-		goto exit_init_failed;
+	if (err < 0) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: set power down mode error\n");
+		goto exit3;
 	}
+	else
+		printk("AKM8975 akm8975_probe: Get Device ID Success!!\n");
 	
-
-	/* Register sysfs attribute */
-	if(err = akm8975_create_attr(&akm_sensor_driver.driver))
-	{
-		printk(KERN_ERR "create attribute err = %d\n", err);
-		goto exit_sysfs_create_group_failed;
+#ifdef AKM8975_USING_IRQ
+	/* IRQ */
+	err = request_irq(client->irq, akm8975_interrupt, IRQ_TYPE_EDGE_RISING,
+					  "akm8975_DRDY", akm);
+	if (err < 0) {
+		printk(KERN_ERR "AKM8975 akm8975_probe: request irq failed\n");
+		goto exit4;
 	}
-
+#endif
 	
-	if(err = misc_register(&akm8975_device))
-	{
-		printk(KERN_ERR "akm8975_device register failed\n");
-		goto exit_misc_device_register_failed;	}    
+	/* Declare input device */
+	akm->input_dev = input_allocate_device();
+	if (!akm->input_dev) {
+		err = -ENOMEM;
+		printk(KERN_ERR
+		       "AKM8975 akm8975_probe: Failed to allocate input device\n");
+		goto exit5;
+	}
+	/* Setup input device */
+	set_bit(EV_ABS, akm->input_dev->evbit);
+	/* yaw (0, 360) */
+	input_set_abs_params(akm->input_dev, ABS_RX, 0, 23040, 0, 0);
+	/* pitch (-180, 180) */
+	input_set_abs_params(akm->input_dev, ABS_RY, -11520, 11520, 0, 0);
+	/* roll (-90, 90) */
+	input_set_abs_params(akm->input_dev, ABS_RZ, -5760, 5760, 0, 0);
+	/* x-axis acceleration (720 x 8G) */
+	input_set_abs_params(akm->input_dev, ABS_X, -5760, 5760, 0, 0);
+	/* y-axis acceleration (720 x 8G) */
+	input_set_abs_params(akm->input_dev, ABS_Y, -5760, 5760, 0, 0);
+	/* z-axis acceleration (720 x 8G) */
+	input_set_abs_params(akm->input_dev, ABS_Z, -5760, 5760, 0, 0);
+	/* temparature */
 
-	sobj_m.self = data;
-    sobj_m.polling = 1;
-    sobj_m.sensor_operate = akm8975_operate;
-	if(err = hwmsen_attach(ID_MAGNETIC, &sobj_m))
-	{
-		printk(KERN_ERR "attach fail = %d\n", err);
-		goto exit_kfree;
-	}
+	input_set_abs_params(akm->input_dev, ABS_DISTANCE, 0, 1, 0, 0);
 	
-	sobj_o.self = data;
-    sobj_o.polling = 1;
-    sobj_o.sensor_operate = akm8975_orientation_operate;
-	if(err = hwmsen_attach(ID_ORIENTATION, &sobj_o))
-	{
-		printk(KERN_ERR "attach fail = %d\n", err);
-		goto exit_kfree;
+	/*
+	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
+	 */
+	/* status of magnetic sensor */
+	input_set_abs_params(akm->input_dev, ABS_RUDDER, -32768, 3, 0, 0);
+	/* status of acceleration sensor */
+	input_set_abs_params(akm->input_dev, ABS_WHEEL, -32768, 3, 0, 0);
+	/* x-axis of raw magnetic vector (-4096, 4095) */
+	input_set_abs_params(akm->input_dev, ABS_HAT0X, -20480, 20479, 0, 0);
+	/* y-axis of raw magnetic vector (-4096, 4095) */
+	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -20480, 20479, 0, 0);
+	/* z-axis of raw magnetic vector (-4096, 4095) */
+	input_set_abs_params(akm->input_dev, ABS_BRAKE, -20480, 20479, 0, 0);
+	/* Set name */
+	akm->input_dev->name = "compass";
+	
+	/* Register */
+	err = input_register_device(akm->input_dev);
+	if (err) {
+		printk(KERN_ERR
+		       "AKM8975 akm8975_probe: Unable to register input device\n");
+		goto exit6;
+	}
+	
+	err = misc_register(&akmd_device);
+	if (err) {
+		printk(KERN_ERR
+			   "AKM8975 akm8975_probe: akmd_device register failed\n");
+		goto exit7;
+	}
+	
+	err = misc_register(&akm_aot_device);
+	if (err) {
+		printk(KERN_ERR
+		       "AKM8975 akm8975_probe: akm_aot_device register failed\n");
+		goto exit8;
+	}
+	
+	//For Factory TEST
+	if (device_create_file(akmd_device.this_device, &dev_attr_ak_file) < 0) {
+		printk(KERN_ERR "Failed to create device file(%s)!\n", dev_attr_ak_file.attr.name);
+		goto exit9;
 	}
+
+#ifdef AKM8975_USING_IRQ
+	mutex_init(&sense_data_mutex);
 	
-#if CONFIG_HAS_EARLYSUSPEND
-	data->early_drv.level    = EARLY_SUSPEND_LEVEL_DISABLE_FB - 1,
-	data->early_drv.suspend  = akm8975_early_suspend,
-	data->early_drv.resume   = akm8975_late_resume,    
-	register_early_suspend(&data->early_drv);
+	init_waitqueue_head(&data_ready_wq);
 #endif
-
-	AKMDBG("%s: OK\n", __func__);
-	return 0;
-
-	exit_sysfs_create_group_failed:   
-	exit_init_failed:	
-	exit_misc_device_register_failed:
-	exit_kfree:
-	kfree(data);
-	exit:
-	printk(KERN_ERR "%s: err = %d\n", __func__, err);
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-static int akm8975_i2c_remove(struct i2c_client *client)
-{
-	int err;	
+	init_waitqueue_head(&open_wq);
 	
-	if(err = akm8975_delete_attr(&akm_sensor_driver.driver))
-	{
-		printk(KERN_ERR "akm8975_delete_attr fail: %d\n", err);
-	}
+	/* As default, report all information */
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&mv_flag, 1);
+	atomic_set(&p_flag, 1);
 	
-	this_client = NULL;
-	i2c_unregister_device(client);
-	kfree(i2c_get_clientdata(client));	
-	misc_deregister(&akm8975_device);    
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int akm_probe(struct platform_device *pdev) 
-{
-	struct mag_hw *hw = get_cust_mag_hw();
-
-	akm8975_power(hw, 1);
+#if 0
+	akm->akm_early_suspend.suspend = akm8975_early_suspend;
+	akm->akm_early_suspend.resume = akm8975_early_resume;
+	register_early_suspend(&akm->akm_early_suspend);
+#endif
 	
-	atomic_set(&dev_open_count, 0);
-	//akm8975_force[0] = hw->i2c_num;
-
-	if(i2c_add_driver(&akm8975_i2c_driver))
-	{
-		printk(KERN_ERR "add driver error\n");
-		return -1;
-	} 
+	AKMDBG("successfully probed.");
 	return 0;
+	
+exit9:
+	misc_deregister(&akm_aot_device);
+exit8:
+	misc_deregister(&akmd_device);
+exit7:
+	input_unregister_device(akm->input_dev);
+exit6:
+	input_free_device(akm->input_dev);
+exit5:
+#ifdef AKM8975_USING_IRQ
+	free_irq(client->irq, akm);
+#endif
+exit4:
+exit3:
+exit2:
+	kfree(akm);
+exit1:
+exit0:
+	return err;
+	
 }
-/*----------------------------------------------------------------------------*/
-static int akm_remove(struct platform_device *pdev)
+
+static int akm8975_remove(struct i2c_client *client)
 {
-	struct mag_hw *hw = get_cust_mag_hw();
- 
-	akm8975_power(hw, 0);    
-	atomic_set(&dev_open_count, 0);  
-	i2c_del_driver(&akm8975_i2c_driver);
+	struct akm8975_data *akm = i2c_get_clientdata(client);
+	AKMFUNC("akm8975_remove");
+	unregister_early_suspend(&akm->akm_early_suspend);
+	misc_deregister(&akm_aot_device);
+	misc_deregister(&akmd_device);
+	input_unregister_device(akm->input_dev);
+#ifdef AKM8975_USING_IRQ
+	free_irq(client->irq, akm);
+#endif
+	kfree(akm);
+	AKMDBG("successfully removed.");
 	return 0;
 }
-/*----------------------------------------------------------------------------*/
+
+static const struct i2c_device_id akm8975_id[] = {
+	{AKM8975_I2C_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver akm8975_driver = {
+	.probe		= akm8975_probe,
+	.remove 	= akm8975_remove,
+	.suspend	= akm8975_suspend,
+	.resume		= akm8975_resume,
+	.id_table	= akm8975_id,
+	.driver = {
+		.name = AKM8975_I2C_NAME,
+	},
+};
+
 static int __init akm8975_init(void)
 {
-	i2c_register_board_info(0, &i2c_akm8975, 1);
-
-	if(platform_driver_register(&akm_sensor_driver))
-	{
-		printk(KERN_ERR "failed to register driver");
-		return -ENODEV;
-	}
-	return 0;    
+	printk(KERN_INFO "AKM8975 compass driver: initialize\n");
+	return i2c_add_driver(&akm8975_driver);
 }
-/*----------------------------------------------------------------------------*/
+
 static void __exit akm8975_exit(void)
-{	
-	platform_driver_unregister(&akm_sensor_driver);
+{
+	printk(KERN_INFO "AKM8975 compass driver: release\n");
+	i2c_del_driver(&akm8975_driver);
 }
-/*----------------------------------------------------------------------------*/
+
 module_init(akm8975_init);
 module_exit(akm8975_exit);
 
-MODULE_AUTHOR("chunlei wang");
+MODULE_AUTHOR("viral wang <viral_wang@htc.com>");
 MODULE_DESCRIPTION("AKM8975 compass driver");
 MODULE_LICENSE("GPL");
-MODULE_VERSION(DRIVER_VERSION);
+
